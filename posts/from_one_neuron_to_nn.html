<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>From One Neuron to a Neural Network</title>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']]
            }
        };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            max-width: 720px;
            margin: 0 auto;
            padding: 40px 20px;
            line-height: 1.8;
            color: #1a1a1a;
            background: #fafafa;
        }
        .back {
            display: inline-block;
            margin-bottom: 40px;
            color: #666;
            text-decoration: none;
            font-size: 14px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        .back:hover { color: #1a1a1a; }
        .post-header {
            margin-bottom: 48px;
        }
        .post-content img {
            display: block;
            margin: 24px auto;
            max-width: 100%;
        }
        .note { 
            background: #f0f7ff; 
            border-left: 4px solid #4a9eff; 
            padding: 16px 20px; 
            border-radius: 0 8px 8px 0; 
            margin: 24px 0; 
            font-family: Verdana, Geneva, sans-serif; 
            font-size: 14px; }
        .post-header h1 {
            font-size: 32px;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 8px;
            color: #111;
        }
        .post-date {
            color: #888;
            font-size: 14px;
            letter-spacing: 0.3px;
        }
        .post-content h2 {
            font-size: 24px;
            margin-top: 48px;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        .post-content h3 {
            font-size: 20px;
            margin-top: 36px;
            margin-bottom: 12px;
        }
        .post-content h4 {
            font-size: 17px;
            margin-top: 28px;
            margin-bottom: 10px;
        }
        .post-content h5 {
            font-size: 15px;
            margin-top: 24px;
            margin-bottom: 8px;
        }
        .post-content p {
            margin-bottom: 16px;
        }
        .post-content code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 90%;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }
        .post-content pre {
            background: #1a1a1a;
            color: #e6e6e6;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
        }
        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
        }
        .post-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        .post-content th, .post-content td {
            border: 1px solid #e1e4e8;
            padding: 10px 14px;
            text-align: left;
        }
        .post-content th {
            background: #f6f8fa;
            font-weight: 600;
        }
        .post-content strong { color: #111; }
        .post-content blockquote {
            border-left: 3px solid #ddd;
            padding: 0 16px;
            color: #666;
            margin: 20px 0;
        }
        .post-content ul, .post-content ol {
            margin: 12px 0;
            padding-left: 24px;
        }
        .post-content li {
            margin-bottom: 6px;
        }
        .math-block {
            margin: 8px 0;
            overflow-x: auto;
        }
        .math-block + .math-block {
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <a href="/" class="back">‚Üê back</a>
    <div class="post-header">
        <h1>From One Neuron to a Neural Network</h1>
        <div class="post-date">February 18, 2025</div>
    </div>
    <div class="post-content">
        <h1>From One Neuron to a Neural Network</h1>

<p>In the previous post, our neuron had one input: <span class="math-inline">$y = wx + b$</span>. But a real neuron in a network receives many inputs. Think about MNIST - each image is 784 pixels. One neuron needs to take all 784 values and produce one output.</p>

<div class="math-block">$$\hat{y} = (w_1 \cdot x_1 + w_2 \cdot x_2 + w_3 \cdot x_3 + ... + w_{784} \cdot x_{784}) + b$$</div>

<div class="math-block">$$\hat{y} = \sum_{i=1}^{784} w_i \cdot x_i + b$$</div>

<p>In Python (using NumPy), this can be represented as:</p>

<div class="codehilite">
<pre><span></span><code><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>
<span class="c1"># or</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">w</span> <span class="o">@</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>
</code></pre>
</div>

<p>Yes, that's 784 multiplications and additions in one operation. That's the power of NumPy.</p>

<p>But wait, what does this computation of a neuron actually represent? Let's think about this concretely.
A neuron takes 784 pixel values, multiplies each by a weight and sums them up. Some weights are big, some are small, some might be negative.</p>

<p>If a weight for pixel #200 is large and positive, what does that mean? The neuron <strong>cares a lot</strong> about that pixel being bright.
If a weight for pixel #500 is large and negative? The neuron wants that pixel to be <strong>dark</strong>.
If a weight is near zero? The neuron <strong>doesn't care</strong> about that pixel.</p>

<p>So essentially, the output of a neuron really represents the following: <strong>how much does this input match the pattern this neuron is looking for?</strong></p>

<p>A neuron is a <em>pattern detector</em>. Its weights define what pattern it's sensitive to. Given all this, one neuron detects one pattern. To classify 10 different digits, you need mulitple neurons, each looking for a different pattern. That's why we need something called a <strong>layer</strong> of neurons.</p>

<h2>Multiple Neurons</h2>

<p>A single neuron has 784 weights and produces 1 output. If we want 10 neurons (one per digit), each has its own 784 weights.</p>

<pre><code>Neuron 0: 784 weights -&gt; 1 output
Neuron 1: 784 weights -&gt; 1 output
...
Neuron 9: 784 weights -&gt; 1 output
</code></pre>

<p>Instead of running 10 separate dot products, how can we organize all these weights so that we can compute 10 outputs at once?</p>

<p>We can stack all the weights into a single <strong>matrix</strong> and compute all 10 outputs at once. Here's how:</p>

<div class="math-block">$$\begin{bmatrix} y_0 & y_1 & \cdots & y_9 \end{bmatrix} = \begin{bmatrix} x_0 & x_1 & \cdots & x_{783} \end{bmatrix} \cdot \begin{bmatrix} w_{0,0} & w_{0,1} & \cdots & w_{0,9} \\ w_{1,0} & w_{1,1} & \cdots & w_{1,9} \\ \vdots & \vdots & \ddots & \vdots \\ w_{783,0} & w_{783,1} & \cdots & w_{783,9} \end{bmatrix} + \begin{bmatrix} b_0 & b_1 & \cdots & b_9 \end{bmatrix}$$</div>

<p>In NumPy, this entire operation is just:</p>

<div class="codehilite">
<pre><span></span><code><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">@</span> <span class="n">W</span> <span class="o">+</span> <span class="n">b</span>
<span class="c1"># (784,) @ (784, 10) + (10,) ‚Üí (10,)</span>
<span class="c1"># 784 inputs, 784 weights, 10 neurons and 10 outputs.</span>
</code></pre>
</div>

<p>10 neurons, 784 weights each, all computed in one line.</p>

<p><img src="/images/arch_1.png" alt="Network so far" /></p>

<div class="note">
<strong>üìù NumPy Shapes</strong><br>
<p style="italic">Every array in NumPy has a shape. A shape of <code>(3,)</code> means 3 numbers in a row. A shape of <code>(2, 3)</code> means 2 rows and 3 columns. When you multiply arrays with <code>@</code>, the inner dimensions must match and they disappear ‚Äî the outer dimensions survive. So <code>(2, 3) @ (3, 4)</code> gives <code>(2, 4)</code> because the 3s match and vanish. If the inner dimensions don't match, NumPy throws an error. This one rule governs every matrix operation in a neural network. </p>
</div>

<p>Now that we have something that allows us to spin up 10 neurons that gives us 10 outputs, is that enough to classify digits? We'll call this a <strong>layer</strong>. This one layer does <code>x @ W + b</code>, and this is a linear function. It can only draw straight lines to separate things. Let's plot some 3's and 8's on a graph and see if a straight line can separate them.</p>

<p><img src="/images/linear_separation.png" alt="Can a straight line separate &quot;3s&quot; from 8s&quot;?" /></p>

<p>The graph above shows 500 handwritten digits plotted as points in 2D space. Blue dots are 3s, red dots are 8s. Try drawing a single straight line that puts all the blue on one side and all the red on the other. It's impossible. They're mixed together.</p>

<p>A single linear layer can only draw straight boundaries, which means it will never perfectly separate these digits. You might think, what if we just stack more layers?</p>

<p>Let's try two layers:</p>

<div class="math-block">$$\text{Layer 1: } z = W_1 \cdot x + b_1$$</div>

<div class="math-block">$$\text{Layer 2: } y = W_2 \cdot z + b_2$$</div>

<p>Substituting layer 1 into layer 2:</p>

<div class="math-block">$$y = W_2 \cdot (W_1 \cdot x + b_1) + b_2$$</div>

<div class="math-block">$$y = (W_2 \cdot W_1) \cdot x + (W_2 \cdot b_1 + b_2)$$</div>

<div class="math-block">$$y = W_{combined} \cdot x + b_{combined}$$</div>

<p>It collapsed back into a single linear function. No matter how many linear layers you stack, the result is always just one straight line. Depth is useless without something to break the linearity.</p>

<p>We need something between the layers that <strong>bends</strong> the output. Something that makes a straight line into a curve. This is called an <strong>activation function</strong>, and the simplest one is called <strong>ReLU</strong>.</p>

<h2>What is an activation function?</h2>

<p>An activation function sits between layers. It takes the output from the previous linear layer, transforms it in a non-linear way, and passes the result to the next layer. As we saw above, this transformation from linear to non-linear is necessary, otherwise the layers will collapse. The activation function prevents that collapse.</p>

<p>One such example of an activation function that's commonly used is called <strong>ReLU</strong>. It's a pretty convenient function. All it does is it if the value is positive, it <em>keeps</em> it, and if the value is negative, it returns <em>zero</em>.</p>

<div class="math-block">$$ ReLU(x) = max(0, x) $$</div>

<p><img src="/images/relu.png" alt="ReLU" /></p>

<p>Let's add ReLU to our ongoing network!</p>

<p><img src="/images/arch_2.png" alt="add activation function" /></p>

<h2>Stacking Layers</h2>

<p>At this point we'll start thinking of our network in terms of <strong>layers</strong>. Our network currently takes 784 inputs, passes them through a linear layer with 10 neurons (one per digit), and each output goes through ReLU. The hope is that each neuron has learned to detect a specific digit.</p>

<p>But is that realistic? Can a single neuron really learn to recognize every possible way someone writes a "3"?</p>

<p>One neuron per digit means each must detect the entire pattern by itself. What if instead we had 128 neurons detecting parts such as curves, edges and loops. Then add another layer which combines parts into digits.</p>

<p>Think about how you recognize an "8". You don't memorize every possible pixel arrangement. You see two loops stacked on top of each other. Your brain detects <strong>parts</strong> first, then combines them.</p>

<p>That's exactly what stacking layers does:</p>

<ul>
<li><strong>Layer 1</strong> (784 ‚Üí 128): 128 neurons each learn to detect simple patterns such as edges, curves, strokes, loops.</li>
<li><strong>Layer 2</strong> (128 ‚Üí 64): 64 neurons combine those simple patterns into higher-level features like loops, corners, intersections.</li>
<li><strong>Layer 3</strong> (64 ‚Üí 10): 10 neurons combine those features into final digit classifications</li>
</ul>

<p>Each layer compresses the information further, from raw pixels to parts to patterns to answers.</p>

<p><img src="/images/arch_full.png" alt="Full architecture" /></p>

<p>There's no formula for choosing the right number of neurons. The output layer is fixed by your problem: 10 classes means 10 neurons. For hidden layers, start with something reasonable and experiment. Too few neurons and the network can't learn enough patterns. Too many and it might <strong>memorize</strong> the training data instead of learning general patterns (this is called <strong>overfitting</strong> ‚Äî like a student who memorizes exam answers but can't solve new problems). A common starting point is to shrink gradually from input to output, giving early layers more neurons to capture many simple patterns and later layers fewer neurons to combine them. Numbers like 128 and 64 are popular partly because powers of 2 run slightly faster on hardware, but there's nothing magical about them. The real answer is: try something, train it, see if it works, adjust, repeat. Choosing layer sizes is more art than science.</p>

<h2>Backpropagation through Layers</h2>

<p>We have the architecture. Now, how does it learn?</p>

<p>We already understand the core idea from our previous post. For a single neuron, we used the loss as a starting point and measured how much the loss changes when we wiggle <span class="math-inline">$\hat{y}$</span>. Then, using the chain rule, we figured out how to update the weights and bias to minimize the loss. This is <strong>backpropagation</strong>.</p>

<p>The same idea applies here ‚Äî but instead of a single neuron with single values, we now have <strong>layers</strong> with <strong>matrices</strong> of weights and activation functions in between. Let's walk through it step by step.</p>

<ul>
<li>Start from the loss, work backward</li>
<li>Trace the gradient backward through the last linear layer</li>
<li>Each layer receives a gradient, and computes three things:
<ol>
<li>Gradient for its weights (to update them)</li>
<li>Gradient for its bias (to update it)</li>
<li>Graident to pass backward(to keep the chain going)</li>
</ol></li>
<li>ReLU just passes gradient through where input was positive, blocks where negative.</li>
</ul>

<h4>How does a gradient flow through a Linear layer?</h4>

<p>Let's start by comparing what we already know with what we need to learn.</p>

<p>For our single neuron, the forward pass was:</p>

<div class="math-block">$$\hat{y} = w \cdot x + b$$</div>

<p>And we computed the gradients using the chain rule:</p>

<div class="math-block">$$\frac{dL}{dw} = \frac{dL}{d\hat{y}} \cdot x \quad \quad \frac{dL}{db} = \frac{dL}{d\hat{y}} \cdot 1$$</div>

<p>For a layer of neurons, the forward pass looks almost identical but just with matrices:</p>

<div class="math-block">$$Y = X \cdot W + b$$</div>

<p>And the gradients follow the exact same logic:</p>

<table>
<thead>
<tr>
  <th></th>
  <th>Single Neuron</th>
  <th>Layer of Neurons</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Forward</strong></td>
  <td><span class="math-inline">$\hat{y} = w \cdot x + b$</span></td>
  <td><span class="math-inline">$Y = X \cdot W + b$</span></td>
</tr>
<tr>
  <td><strong>Weight gradient</strong></td>
  <td><span class="math-inline">$\frac{dL}{dw} = \frac{dL}{d\hat{y}} \cdot x$</span></td>
  <td><span class="math-inline">$\frac{dL}{dW} = X^T \cdot \frac{dL}{dY}$</span></td>
</tr>
<tr>
  <td><strong>Bias gradient</strong></td>
  <td><span class="math-inline">$\frac{dL}{db} = \frac{dL}{d\hat{y}}$</span></td>
  <td><span class="math-inline">$\frac{dL}{db} = \sum \frac{dL}{dY}$</span></td>
</tr>
<tr>
  <td><strong>Pass backward</strong></td>
  <td><span class="math-inline">$\frac{dL}{dx} = \frac{dL}{d\hat{y}} \cdot w$</span></td>
  <td><span class="math-inline">$\frac{dL}{dX} = \frac{dL}{dY} \cdot W^T$</span></td>
</tr>
</tbody>
</table>

<p>It's the same idea ‚Äî just scaled up. Let's break down each one.</p>

<p><strong>Weight gradient:</strong> <span class="math-inline">$\frac{dL}{dW} = X^T \cdot \frac{dL}{dY}$</span></p>

<p>In the single neuron case, the weight gradient was the input multiplied by the incoming gradient. Same thing here ‚Äî <span class="math-inline">$X^T$</span> is our input (transposed to make the shapes work) multiplied by the gradient flowing in from the next layer.</p>

<p><strong>Bias gradient:</strong> <span class="math-inline">$\frac{dL}{db} = \sum \frac{dL}{dY}$</span></p>

<p>For a single neuron, the bias gradient was just the incoming gradient (multiplied by 1). For a layer processing a batch of samples, each sample contributes its own gradient. We sum them up because there's only one bias shared across all samples.</p>

<p><strong>Gradient to pass backward:</strong> <span class="math-inline">$\frac{dL}{dX} = \frac{dL}{dY} \cdot W^T$</span></p>

<p>This is the gradient that gets sent to the previous layer. In the single neuron case, it was the incoming gradient multiplied by the weight. Same here, we multiply by <span class="math-inline">$W^T$</span> (transposed to make the shapes work). This is what keeps the chain going.</p>

<h4>How does a gradient flow through ReLU?</h4>

<p>ReLU's forward pass was simple ‚Äî keep positives, zero out negatives. Its backward pass is just as simple.</p>

<p>Think about it: if ReLU kept a value (it was positive), then a small change in the input causes the same small change in the output. The gradient passes through unchanged.</p>

<p>If ReLU zeroed a value (it was negative), then the output is stuck at zero no matter what. The gradient is blocked and it becomes zero.</p>

<div class="math-block">$$\frac{dL}{dX} = \frac{dL}{dY} \cdot \begin{cases} 1 & \text{if input was positive} \\ 0 & \text{if input was negative} \end{cases}$$</div>

<p>ReLU acts like a gate. It lets the gradient through where the neuron was active, and blocks it where the neuron was dead.</p>

<h4>Putting it all together</h4>

<p>Let's trace the full backward pass through our network:</p>

<div class="math-block">$$\text{Input} \rightarrow \text{Linear}_1 \rightarrow \text{ReLU} \rightarrow \text{Linear}_2 \rightarrow \text{ReLU} \rightarrow \text{Linear}_3 \rightarrow \text{Loss}$$</div>

<p>Starting from the loss, the gradient flows backward:</p>

<ol>
<li><strong>Loss</strong> computes <span class="math-inline">$\frac{dL}{dY_3}$</span> ‚Äî how much the loss changes with respect to the final output. This is our first gradient.</li>
<li><strong>Linear‚ÇÉ</strong> receives this gradient and computes:
<ul>
<li>Its weight and bias gradients (to update its parameters)</li>
<li><span class="math-inline">$\frac{dL}{dX_3}$</span> to pass backward</li>
</ul></li>
<li><strong>ReLU</strong> receives <span class="math-inline">$\frac{dL}{dX_3}$</span> and lets it through where neurons were active, blocks where they were dead</li>
<li><strong>Linear‚ÇÇ</strong> receives the surviving gradient, computes its own weight and bias gradients, and passes another gradient backward</li>
<li><strong>ReLU</strong> gates the gradient again</li>
<li><strong>Linear‚ÇÅ</strong> receives the gradient and computes its weight and bias gradients</li>
</ol>

<p>At the end of this process, every layer has its own weight and bias gradients which is the exact information needed to update the parameters and reduce the loss.</p>

    </div>
</body>
</html>